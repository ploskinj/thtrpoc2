(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // wwwroot/js/classes/Avatar.js
  var Avatar;
  var init_Avatar = __esm({
    "wwwroot/js/classes/Avatar.js"() {
      Avatar = class {
        constructor() {
          this.sex = "male";
          this.skin = 1;
          this.direction = 0;
          this.animation = "idle_normal_loop1";
          this.handle = "";
        }
      };
    }
  });

  // wwwroot/js/classes/AvatarAnimationData.js
  var AvatarAnimationData, _avatar_animation_data;
  var init_AvatarAnimationData = __esm({
    "wwwroot/js/classes/AvatarAnimationData.js"() {
      AvatarAnimationData = class {
        constructor() {
          this.animations = null;
          this.loaded = false;
        }
        async load() {
          if (!this.loaded) {
            await this.load_avatar_json();
            await this.load_avatar_images();
            this.loaded = true;
          }
        }
        async load_avatar_images() {
          const load_promises = [];
          this.animations.forEach((skin_map, sex) => {
            skin_map.forEach((direction_map, skin) => {
              direction_map.forEach((anim_map, direction) => {
                anim_map.forEach((anim_data, anim_key) => {
                  const img = new Image();
                  const img_path = anim_data.sprite_sheet_dir + anim_data.sprite_sheet_file_name;
                  const load_promise = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error(`Failed to load: ${img_path}`));
                    img.src = img_path;
                  });
                  anim_data.img = img;
                  load_promises.push(load_promise);
                });
              });
            });
          });
          await Promise.all(load_promises);
        }
        async load_avatar_json() {
          const response = await fetch("/avatars/avatar.json");
          const avatar_meta_data = await response.json();
          this.animations = /* @__PURE__ */ new Map();
          const sexes = ["male", "female"];
          const skins = [1, 2, 3, 4];
          const directions = ["north", "south", "east", "west"];
          const direction_prefixes = {
            "north": "n",
            "south": "s",
            "east": "e",
            "west": "w"
          };
          sexes.forEach((sex) => {
            this.animations.set(sex, /* @__PURE__ */ new Map());
            skins.forEach((skin) => {
              this.animations.get(sex).set(skin, /* @__PURE__ */ new Map());
              directions.forEach((direction) => {
                this.animations.get(sex).get(skin).set(direction, /* @__PURE__ */ new Map());
                avatar_meta_data.animations.forEach((anim_obj) => {
                  const anim_key = Object.keys(anim_obj)[0];
                  const anim_data = { ...anim_obj[anim_key] };
                  anim_data.sprite_sheet_file_name = anim_data.sprite_sheet_file_name.replace("{dir}", direction_prefixes[direction]);
                  anim_data.sprite_sheet_dir = avatar_meta_data.sprite_sheet_dir.replace("{sex}", sex).replace("{skin}", skin);
                  this.animations.get(sex).get(skin).get(direction).set(anim_key, anim_data);
                });
              });
            });
          });
        }
      };
      _avatar_animation_data = new AvatarAnimationData();
    }
  });

  // wwwroot/js/classes/InputManager.js
  var InputManager, _input_manager;
  var init_InputManager = __esm({
    "wwwroot/js/classes/InputManager.js"() {
      InputManager = class {
        constructor() {
          this._up = false;
          this._down = false;
          this._left = false;
          this._right = false;
          this._attack = false;
          this._input = { UP: 0, DOWN: 1, LEFT: 2, RIGHT: 3, ATTACK: 4 };
          this._code_map = {
            "KeyW": this._input.UP,
            "ArrowUp": this._input.UP,
            "KeyS": this._input.DOWN,
            "ArrowDown": this._input.DOWN,
            "KeyA": this._input.LEFT,
            "ArrowLeft": this._input.LEFT,
            "KeyD": this._input.RIGHT,
            "ArrowRight": this._input.RIGHT,
            "KeyJ": this._input.ATTACK,
            "KeyK": this._input.ATTACK
          };
          this._on_up_down = null;
          this._on_up_up = null;
          this._on_down_down = null;
          this._on_down_up = null;
          this._on_left_down = null;
          this._on_left_up = null;
          this._on_right_down = null;
          this._on_right_up = null;
          this._on_attack_down = null;
          this._on_attack_up = null;
        }
        instantiate_input() {
          $(document).on("keydown keyup", (e) => {
            const action = this._code_map[e.code];
            if (action === void 0) return;
            const is_pressed = e.type === "keydown";
            switch (action) {
              case this._input.UP:
                if (this._up !== is_pressed) {
                  this._up = is_pressed;
                  if (is_pressed && this._on_up_down) this._on_up_down();
                  if (!is_pressed && this._on_up_up) this._on_up_up();
                }
                break;
              case this._input.DOWN:
                if (this._down !== is_pressed) {
                  this._down = is_pressed;
                  if (is_pressed && this._on_down_down) this._on_down_down();
                  if (!is_pressed && this._on_down_up) this._on_down_up();
                }
                break;
              case this._input.LEFT:
                if (this._left !== is_pressed) {
                  this._left = is_pressed;
                  if (is_pressed && this._on_left_down) this._on_left_down();
                  if (!is_pressed && this._on_left_up) this._on_left_up();
                }
                break;
              case this._input.RIGHT:
                if (this._right !== is_pressed) {
                  this._right = is_pressed;
                  if (is_pressed && this._on_right_down) this._on_right_down();
                  if (!is_pressed && this._on_right_up) this._on_right_up();
                }
                break;
              case this._input.ATTACK:
                if (this._attack !== is_pressed) {
                  this._attack = is_pressed;
                  if (is_pressed && this._on_attack_down) this._on_attack_down();
                  if (!is_pressed && this._on_attack_up) this._on_attack_up();
                }
            }
            e.preventDefault();
          });
        }
        get_up() {
          return this._up;
        }
        get_down() {
          return this._down;
        }
        get_left() {
          return this._left;
        }
        get_right() {
          return this._right;
        }
        get_attack() {
          return this._attack;
        }
        get_state() {
          return {
            up: this._up,
            down: this._down,
            left: this._left,
            right: this._right,
            attack: this._attack
          };
        }
      };
      _input_manager = new InputManager();
    }
  });

  // wwwroot/js/classes/SetAvatar.js
  var SetAvatar;
  var init_SetAvatar = __esm({
    "wwwroot/js/classes/SetAvatar.js"() {
      SetAvatar = class {
        constructor() {
          this._body_animation_textures = /* @__PURE__ */ new Map();
          this._sprite = null;
        }
        async instantiate(body_animation_data, sprite_sheet_dir) {
          const animation_promises = Array.from(body_animation_data.entries()).map(async ([animation_name, animation_data]) => {
            const textures = await this._create_textures_from_spritesheet(animation_data, sprite_sheet_dir);
            this._body_animation_textures.set(animation_name, textures);
          });
          await Promise.all(animation_promises);
          const idle_textures = this._body_animation_textures.get("idle_normal_loop1");
          if (idle_textures && idle_textures.length > 0) {
            this._sprite = new PIXI.Sprite(idle_textures[0]);
          }
        }
        get_sprite() {
          return this._sprite;
        }
        async _create_textures_from_spritesheet(animation_data, sprite_sheet_dir) {
          const textures = [];
          const frame_width = animation_data.frame_width;
          const num_frames = animation_data.num_frames;
          const sprite_path = "/images/avatars/male_color1/" + animation_data.sprite_sheet_file_name;
          const source_texture = await PIXI.Assets.load(sprite_path);
          source_texture.source.scaleMode = "nearest";
          for (let i = 0; i < num_frames; i++) {
            const frame_x = i * frame_width;
            const frame_y = 0;
            const frame_rect = new PIXI.Rectangle(frame_x, frame_y, frame_width, frame_width);
            const frame_texture = new PIXI.Texture({
              source: source_texture.source,
              frame: frame_rect
            });
            textures.push(frame_texture);
          }
          return textures;
        }
      };
    }
  });

  // wwwroot/js/classes/SetManager.js
  var SetManager;
  var init_SetManager = __esm({
    "wwwroot/js/classes/SetManager.js"() {
      SetManager = class {
        constructor() {
          this._pixi_app = null;
        }
        async instantiate() {
          this._pixi_app = new PIXI.Application();
          const window_width = window.innerWidth * 0.9;
          const scale_factor = window_width / 320;
          await this._pixi_app.init({
            width: 320,
            height: 180,
            resolution: scale_factor,
            autoDensity: true,
            antialias: false,
            roundPixels: true
          });
          this._pixi_app.canvas.style.width = `${window_width}px`;
          this._pixi_app.canvas.style.height = `${180 * scale_factor}px`;
          this._pixi_app.canvas.style.imageRendering = "pixelated";
          document.body.appendChild(this._pixi_app.canvas);
        }
        async make_entrance(child) {
          this._pixi_app.stage.addChild(child);
        }
        async make_exit(child) {
          this._pixi_app.stage.removeChild(child);
        }
      };
    }
  });

  // wwwroot/js/classes/SignalRManager.js
  var SignalRManager, _signal_r_manager;
  var init_SignalRManager = __esm({
    "wwwroot/js/classes/SignalRManager.js"() {
      init_InputManager();
      SignalRManager = class {
        constructor(hub_url) {
          this._connection = null;
          this._hub_url = hub_url;
          this._is_connected = false;
          this._reconnect_delay = 5e3;
          this._tick_callback = null;
          this._connected_callback = null;
          this._disconnected_callback = null;
        }
        async start() {
          this._connection = new signalR.HubConnectionBuilder().withUrl(this._hub_url).withHubProtocol(new signalR.protocols.msgpack.MessagePackHubProtocol()).withAutomaticReconnect().configureLogging(signalR.LogLevel.Information).build();
          this._connection.on("receive_tick", (timestamp) => {
            if (this._tick_callback) {
              this._tick_callback(timestamp);
            }
          });
          this._connection.onclose(() => {
            this._is_connected = false;
            if (this._disconnected_callback) {
              this._disconnected_callback();
            }
            this._attempt_reconnect();
          });
          this._connection.onreconnected(() => {
            this._is_connected = true;
            if (this._connected_callback) {
              this._connected_callback();
            }
          });
          _input_manager._on_up_down = () => this.invoke_server_method("client_up_down");
          _input_manager._on_up_up = () => this.invoke_server_method("client_up_up");
          _input_manager._on_down_down = () => this.invoke_server_method("client_down_down");
          _input_manager._on_down_up = () => this.invoke_server_method("client_down_up");
          _input_manager._on_left_down = () => this.invoke_server_method("client_left_down");
          _input_manager._on_left_up = () => this.invoke_server_method("client_left_up");
          _input_manager._on_right_down = () => this.invoke_server_method("client_right_down");
          _input_manager._on_right_up = () => this.invoke_server_method("client_right_up");
          _input_manager._on_attack_down = () => this.invoke_server_method("client_attack_down");
          _input_manager._on_attack_up = () => this.invoke_server_method("client_attack_up");
          try {
            await this._connection.start();
            this._is_connected = true;
            console.log("Its connected!");
            if (this._connected_callback) {
              this._connected_callback();
            }
          } catch (error) {
            console.error("SignalR connection failed:", error);
            this._attempt_reconnect();
          }
        }
        async _attempt_reconnect() {
          if (!this._is_connected) {
            setTimeout(() => this.start(), this._reconnect_delay);
          }
        }
        async stop() {
          if (this._connection) {
            await this._connection.stop();
            this._is_connected = false;
          }
        }
        on_tick(callback) {
          this._tick_callback = callback;
        }
        on_connected(callback) {
          this._connected_callback = callback;
        }
        on_disconnected(callback) {
          this._disconnected_callback = callback;
        }
        get is_connected() {
          return this._is_connected;
        }
        async invoke_server_method(method_name, ...args) {
          if (this._is_connected) {
            try {
              return await this._connection.invoke(method_name, ...args);
            } catch (error) {
              console.error(`Failed to invoke ${method_name}:`, error);
              throw error;
            }
          }
        }
      };
      _signal_r_manager = new SignalRManager("/poctick");
    }
  });

  // wwwroot/js/modals/ModalControllerBase.js
  var init_ModalControllerBase = __esm({
    "wwwroot/js/modals/ModalControllerBase.js"() {
    }
  });

  // wwwroot/js/modals/ModalManager.js
  var ModalManager, _modal_manager;
  var init_ModalManager = __esm({
    "wwwroot/js/modals/ModalManager.js"() {
      init_ModalControllerBase();
      ModalManager = class {
        constructor() {
          this.active_controller = null;
          this.container = $("#modal_container");
          this.callback = null;
        }
        async open(key, callback) {
          var html_content = await (await fetch(`/Modal/Fetch/${key}`)).text();
          const module = await import(`/js/modals/controllers/${key}.js`);
          this.show_content(html_content);
          this.activeController = new module.Controller();
          this.callback = callback;
        }
        show_content(html_content) {
          this.container.html(html_content);
          this.container.show();
        }
        hide_content() {
          this.container.hide();
        }
        async close() {
          this.callback();
        }
      };
      _modal_manager = new ModalManager();
    }
  });

  // wwwroot/js/THTR.main.js
  var require_THTR_main = __commonJS({
    "wwwroot/js/THTR.main.js"() {
      init_Avatar();
      init_AvatarAnimationData();
      init_InputManager();
      init_SetAvatar();
      init_SetManager();
      init_SignalRManager();
      init_ModalManager();
      var THTR = {
        Avatar,
        SetAvatar,
        SetManager,
        avatar_animation_data: _avatar_animation_data,
        input_manager: _input_manager,
        signal_r_manager: _signal_r_manager,
        modal_manager: _modal_manager,
        Init: async () => {
          await _avatar_animation_data.load();
          console.log("Theater App initialized");
        }
      };
      window.THTR = THTR;
    }
  });
  require_THTR_main();
})();
//# sourceMappingURL=THTR.main.min.js.map
